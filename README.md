#Programming Interview Preparation

First and foremost, work through the Princeton algorithms course. You should follow along and implement as much as you can. Along the way, also implement all these major data structures. (Many of these are not explicitly covered in the course—implement them on your own).

* Linked List
* Dynamic array, implemented with a ring buffer (use a statically sized array underneath the hood)
* Hash set
* Hash map (with chaining)
* Binary heap (without decrease-key; know that Fibonacci heaps exist and know their guarantees)
* Binary search tree (doesn’t need to be self-balancing; know that self-balancing trees exist and know their guarantees)
* Prefix tree (a.k.a. trie)
* Suffix tree (don’t worry about compression, just build a dumb version; know that Ukkonen’s algorithm exists and learn its guarantees)
* An object-oriented adjacency list for graphs
* Know all of the time complexities for their basic operations. It helps to visually intuit them. Look at images. Draw them out on paper/whiteboard.

Once you’ve gotten all of those out of the way, implement this subset of the most common algorithms:

* Binary search (implement it both iteratively and recursively)
* Randomized quicksort (pay extra attention to the partition subroutine, as it’s useful in a lot of places)
* Mergesort
* Breadth-first search in a graph
* Depth-first search in a graph (augment it to detect cycles)
* Tree traversals (pre-order, in-order, post-order)
* Topological sort (using Tarjan’s algorithm)
* Dijkstra’s algorithm (without decrease-key)
* Longest common subsequence (using dynamic programming with matrices)
* Knapsack problem (also dynamic programming)

## Links:
* Road Map: [How to Break Into the Tech Industry—a Guide to Job Hunting and Tech Interviews](http://haseebq.com/how-to-break-into-tech-job-hunting-and-interviews/?utm_content=bufferc78f3&utm_medium=social&utm_source=facebook.com&utm_campaign=buffer)
* Practice: [LeetCode](https://leetcode.com/)
